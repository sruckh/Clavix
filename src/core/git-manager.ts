/**
 * GitManager - Manages git auto-commit functionality for task implementation
 *
 * This class handles:
 * - Checking git repository status
 * - Creating commits based on user preferences
 * - Generating commit messages
 * - Handling commit strategies (per task, per phase, per N tasks)
 */

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Git commit strategy options
 */
export type CommitStrategy =
  | 'per-phase' // Commit when all tasks in a phase are complete
  | 'per-5-tasks' // Commit after every 5 tasks
  | 'per-task' // Commit after each individual task
  | 'none'; // No auto-commits

/**
 * Options for creating a commit
 */
export interface CommitOptions {
  tasks: string[]; // Task descriptions to include in commit message
  phase?: string; // Optional phase name
  projectName?: string; // Optional project name for context
}

/**
 * GitManager class
 *
 * Handles git operations for the implement command
 */
export class GitManager {
  /**
   * Check if current directory is a git repository
   */
  async isGitRepository(): Promise<boolean> {
    try {
      await execAsync('git rev-parse --git-dir');
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check if there are uncommitted changes
   */
  async hasUncommittedChanges(): Promise<boolean> {
    try {
      const { stdout } = await execAsync('git status --porcelain');
      return stdout.trim().length > 0;
    } catch {
      return false;
    }
  }

  /**
   * Create a commit with the given tasks
   */
  async createCommit(options: CommitOptions): Promise<boolean> {
    try {
      // Check for changes first
      if (!(await this.hasUncommittedChanges())) {
        return false; // No changes to commit
      }

      // Stage all changes
      await execAsync('git add .');

      // Generate commit message
      const message = this.generateCommitMessage(options);

      // Create commit
      await execAsync(`git commit -m "${this.escapeCommitMessage(message)}"`);

      return true;
    } catch (error) {
      // If commit fails, log but don't throw
      console.error('Git commit failed:', error);
      return false;
    }
  }

  /**
   * Generate commit message from tasks
   */
  private generateCommitMessage(options: CommitOptions): string {
    const { tasks, phase, projectName } = options;

    let message = '';

    // Header
    if (phase) {
      message += `clavix: ${phase}\n\n`;
    } else if (tasks.length === 1) {
      message += `clavix: ${tasks[0]}\n\n`;
    } else {
      message += `clavix: implement ${tasks.length} tasks\n\n`;
    }

    // Task list
    message += 'Completed tasks:\n';
    tasks.forEach((task) => {
      message += `- ${task}\n`;
    });

    // Footer
    message += '\n';
    if (projectName) {
      message += `Project: ${projectName}\n`;
    }
    message += 'Generated by Clavix /clavix:implement';

    return message;
  }

  /**
   * Escape commit message for shell
   */
  private escapeCommitMessage(message: string): string {
    return message.replace(/"/g, '\\"').replace(/\n/g, '\\n');
  }

  /**
   * Get the current branch name
   */
  async getCurrentBranch(): Promise<string> {
    try {
      const { stdout } = await execAsync('git rev-parse --abbrev-ref HEAD');
      return stdout.trim();
    } catch {
      return 'unknown';
    }
  }

  /**
   * Check if working directory is clean
   */
  async isWorkingDirectoryClean(): Promise<boolean> {
    return !(await this.hasUncommittedChanges());
  }

  /**
   * Get short status for display
   */
  async getStatus(): Promise<string> {
    try {
      const { stdout } = await execAsync('git status --short');
      return stdout.trim();
    } catch {
      return 'Unable to get git status';
    }
  }

  /**
   * Validate git setup before implementing
   */
  async validateGitSetup(): Promise<{
    isRepo: boolean;
    hasChanges: boolean;
    currentBranch: string;
  }> {
    const isRepo = await this.isGitRepository();
    const hasChanges = await this.hasUncommittedChanges();
    const currentBranch = isRepo ? await this.getCurrentBranch() : '';

    return {
      isRepo,
      hasChanges,
      currentBranch,
    };
  }
}

/**
 * Helper class to track when to commit based on strategy
 */
export class CommitScheduler {
  private completedTasksInPhase: number = 0;
  private completedTasksTotal: number = 0;
  private completedTasksSinceLastCommit: number = 0;
  private currentPhase: string = '';

  constructor(private strategy: CommitStrategy) {}

  /**
   * Mark a task as completed and check if commit should be made
   */
  taskCompleted(taskPhase: string): boolean {
    this.completedTasksTotal++;
    this.completedTasksSinceLastCommit++;

    if (taskPhase !== this.currentPhase) {
      this.completedTasksInPhase = 0;
      this.currentPhase = taskPhase;
    }

    this.completedTasksInPhase++;

    return this.shouldCommit();
  }

  /**
   * Mark a phase as completed
   */
  phaseCompleted(): boolean {
    // Reset phase counter
    this.completedTasksInPhase = 0;

    // If strategy is per-phase, we should commit
    return this.strategy === 'per-phase';
  }

  /**
   * Check if a commit should be made now
   */
  private shouldCommit(): boolean {
    switch (this.strategy) {
      case 'per-task':
        return true;

      case 'per-5-tasks':
        return this.completedTasksSinceLastCommit >= 5;

      case 'per-phase':
        // Will be handled by phaseCompleted()
        return false;

      case 'none':
        return false;

      default:
        return false;
    }
  }

  /**
   * Reset commit counter (after a commit is made)
   */
  resetCommitCounter(): void {
    this.completedTasksSinceLastCommit = 0;
  }

  /**
   * Get accumulated task count for commit message
   */
  getTaskCountSinceLastCommit(): number {
    return this.completedTasksSinceLastCommit;
  }
}
