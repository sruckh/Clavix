import { IntentAnalysis, PromptIntent, OptimizationMode } from './types.js';

export class IntentDetector {
  private readonly CODE_KEYWORDS = [
    'function', 'class', 'component', 'api', 'endpoint', 'database',
    'implement', 'build', 'create', 'write', 'code', 'develop',
    'react', 'vue', 'angular', 'python', 'javascript', 'typescript',
    'java', 'rust', 'go', 'php', 'ruby', 'swift', 'kotlin'
  ];

  private readonly PLANNING_KEYWORDS = [
    'plan', 'design', 'architect', 'strategy', 'approach', 'structure',
    'how should', 'what should', 'help me think', 'figure out',
    'organize', 'layout', 'workflow', 'system design'
  ];

  private readonly REFINEMENT_KEYWORDS = [
    'improve', 'optimize', 'refactor', 'enhance', 'better', 'faster',
    'cleaner', 'simplify', 'reduce', 'increase', 'performance',
    'make it', 'change', 'modify', 'update', 'upgrade'
  ];

  private readonly DEBUGGING_KEYWORDS = [
    'fix', 'debug', 'error', 'bug', 'issue', 'problem', 'failing',
    'broken', 'not working', 'crash', 'exception', 'undefined',
    'null', 'incorrect', 'wrong', 'unexpected'
  ];

  private readonly DOCUMENTATION_KEYWORDS = [
    'explain', 'document', 'describe', 'what does', 'how does',
    'understand', 'clarify', 'comment', 'documentation',
    'readme', 'guide', 'tutorial', 'example'
  ];

  analyze(prompt: string): IntentAnalysis {
    const lowerPrompt = prompt.toLowerCase();
    const words = lowerPrompt.split(/\s+/);

    // Calculate scores for each intent type
    const scores = {
      'code-generation': this.calculateScore(lowerPrompt, words, this.CODE_KEYWORDS),
      'planning': this.calculateScore(lowerPrompt, words, this.PLANNING_KEYWORDS),
      'refinement': this.calculateScore(lowerPrompt, words, this.REFINEMENT_KEYWORDS),
      'debugging': this.calculateScore(lowerPrompt, words, this.DEBUGGING_KEYWORDS),
      'documentation': this.calculateScore(lowerPrompt, words, this.DOCUMENTATION_KEYWORDS),
      'prd-generation': 0 // PRD is explicit command, not inferred
    };

    // Find primary intent
    const entries = Object.entries(scores) as [PromptIntent, number][];
    const [primaryIntent, maxScore] = entries.reduce((max, current) =>
      current[1] > max[1] ? current : max
    );

    // Calculate confidence (0-100)
    const totalScore = Object.values(scores).reduce((sum, score) => sum + score, 0);
    const confidence = totalScore > 0
      ? Math.min(100, Math.round((maxScore / totalScore) * 100))
      : 50; // Default confidence if no keywords match

    // Analyze characteristics
    const characteristics = {
      hasCodeContext: this.hasCodeContext(prompt),
      hasTechnicalTerms: this.hasTechnicalTerms(lowerPrompt),
      isOpenEnded: this.isOpenEnded(prompt),
      needsStructure: this.needsStructure(prompt, primaryIntent)
    };

    // Suggest mode based on characteristics
    const suggestedMode: OptimizationMode = this.suggestMode(
      primaryIntent,
      characteristics,
      prompt.length
    );

    return {
      primaryIntent,
      confidence,
      characteristics,
      suggestedMode
    };
  }

  private calculateScore(prompt: string, words: string[], keywords: string[]): number {
    let score = 0;

    for (const keyword of keywords) {
      const keywordWords = keyword.split(/\s+/);

      if (keywordWords.length === 1) {
        // Single word keyword
        if (words.includes(keyword)) {
          score += 10;
        }
      } else {
        // Multi-word phrase
        if (prompt.includes(keyword)) {
          score += 15; // Higher weight for phrase matches
        }
      }
    }

    return score;
  }

  private hasCodeContext(prompt: string): boolean {
    // Check for code blocks (backticks)
    if (prompt.includes('```') || prompt.includes('`')) {
      return true;
    }

    // Check for common code patterns
    const codePatterns = [
      /function\s+\w+\s*\(/,
      /class\s+\w+/,
      /const\s+\w+\s*=/,
      /let\s+\w+\s*=/,
      /var\s+\w+\s*=/,
      /def\s+\w+\s*\(/,
      /import\s+/,
      /from\s+\w+\s+import/,
      /<\w+>/,  // JSX/HTML tags
      /\w+\.\w+\(/  // Method calls
    ];

    return codePatterns.some(pattern => pattern.test(prompt));
  }

  private hasTechnicalTerms(prompt: string): boolean {
    const technicalTerms = [
      'api', 'database', 'sql', 'nosql', 'rest', 'graphql', 'jwt',
      'authentication', 'authorization', 'middleware', 'framework',
      'library', 'package', 'dependency', 'npm', 'pip', 'maven',
      'docker', 'kubernetes', 'aws', 'azure', 'gcp', 'cloud',
      'frontend', 'backend', 'fullstack', 'microservice', 'monolith',
      'ci/cd', 'deployment', 'testing', 'unit test', 'integration test',
      'async', 'await', 'promise', 'callback', 'event', 'listener'
    ];

    return technicalTerms.some(term => prompt.includes(term));
  }

  private isOpenEnded(prompt: string): boolean {
    // Check for question words
    const questionWords = ['how', 'what', 'why', 'when', 'where', 'which', 'should'];
    const lowerPrompt = prompt.toLowerCase();
    const hasQuestionWord = questionWords.some(word => lowerPrompt.startsWith(word));

    // Check for question mark
    const hasQuestionMark = prompt.includes('?');

    // Check for vague language
    const vaguePatterns = [
      'help me', 'i need', 'i want', 'thinking about', 'considering',
      'not sure', 'maybe', 'somehow', 'something like'
    ];
    const hasVagueLanguage = vaguePatterns.some(pattern => lowerPrompt.includes(pattern));

    // Check prompt length (very short prompts tend to be open-ended)
    const isVeryShort = prompt.split(/\s+/).length < 10;

    return (hasQuestionWord || hasQuestionMark || hasVagueLanguage) || isVeryShort;
  }

  private needsStructure(prompt: string, intent: PromptIntent): boolean {
    // Planning always needs structure
    if (intent === 'planning') {
      return true;
    }

    // Check if prompt lacks clear structure
    const hasObjective = /objective|goal|purpose|need to|want to/i.test(prompt);
    const hasRequirements = /requirement|must|should|need|expect/i.test(prompt);
    const hasConstraints = /constraint|limit|within|must not|cannot/i.test(prompt);

    // If missing 2+ of these, needs structure
    const structureScore = [hasObjective, hasRequirements, hasConstraints]
      .filter(Boolean).length;

    return structureScore < 2;
  }

  private suggestMode(
    intent: PromptIntent,
    characteristics: IntentAnalysis['characteristics'],
    promptLength: number
  ): OptimizationMode {
    // Planning tasks usually benefit from deep mode
    if (intent === 'planning') {
      return 'deep';
    }

    // Open-ended tasks benefit from deep mode
    if (characteristics.isOpenEnded && !characteristics.hasCodeContext) {
      return 'deep';
    }

    // Very short prompts might need deep exploration
    if (promptLength < 50 && characteristics.needsStructure) {
      return 'deep';
    }

    // Default to fast mode for well-defined tasks
    return 'fast';
  }
}
