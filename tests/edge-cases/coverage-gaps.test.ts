/**
 * Coverage Gaps Tests
 * Tests uncovered code paths identified in coverage analysis
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import { TaskManager } from '../../src/core/task-manager';
import { PrdGenerator } from '../../src/core/prd-generator';
import { PromptOptimizer } from '../../src/core/prompt-optimizer';

describe('Coverage Gaps', () => {
  const testDir = path.join(__dirname, '../tmp/coverage-gaps-test');

  beforeEach(async () => {
    await fs.ensureDir(testDir);
    process.chdir(testDir);
  });

  afterEach(async () => {
    process.chdir(path.join(__dirname, '../..'));
    await fs.remove(testDir);
  });

  describe('Task Manager - Basic Functionality', () => {
    let taskManager: TaskManager;
    let projectDir: string;

    beforeEach(async () => {
      taskManager = new TaskManager();
      projectDir = path.join(testDir, '.clavix/outputs/test-project');
      await fs.ensureDir(projectDir);
    });

    it('should generate tasks from valid PRD', async () => {
      const prdContent = `# Test Project

## Requirements

### Must-Have Features

#### 1. User Authentication

**Behavior:**
- Create user registration endpoint
- Implement password hashing`;

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), prdContent);
      await taskManager.generateTasksFromPrd(projectDir);

      const tasksContent = await fs.readFile(path.join(projectDir, 'tasks.md'), 'utf-8');

      // Should generate tasks file with header
      expect(tasksContent).toContain('# Implementation Tasks');
      expect(tasksContent).toContain('Generated by Clavix');
      expect(tasksContent.length).toBeGreaterThan(100);
    });

    it('should handle PRD without behaviors', async () => {
      const prdContent = `# Test Project

## Requirements

Basic requirements without structure`;

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), prdContent);
      await taskManager.generateTasksFromPrd(projectDir);

      const tasksContent = await fs.readFile(path.join(projectDir, 'tasks.md'), 'utf-8');

      // Should still generate tasks file
      expect(tasksContent).toBeDefined();
      expect(tasksContent).toContain('# Implementation Tasks');
    });
  });

  describe('Large Input Handling', () => {
    it('should handle very long prompts (50k+ characters)', async () => {
      const longPrompt = 'This is a very detailed requirement. '.repeat(2000); // ~70k chars
      const optimizer = new PromptOptimizer();

      const result = optimizer.improve(longPrompt, 'fast');

      expect(result).toBeDefined();
      expect(result.improved).toBeDefined();
      expect(result.improved.length).toBeGreaterThan(0);
    });

    it('should handle very long PRD content', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/large-project');
      await fs.ensureDir(projectDir);

      const longFeature = `# Large Project

## Requirements

### Must-Have Features

#### 1. ${('Feature Name ').repeat(100)}

**Behavior:**
${Array.from({ length: 100 }, (_, i) => `- Create task ${i + 1}`).join('\n')}

**Technical Details:**
${'Technical detail line. '.repeat(1000)}`;

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), longFeature);

      const taskManager = new TaskManager();
      await taskManager.generateTasksFromPrd(projectDir);

      const tasksContent = await fs.readFile(path.join(projectDir, 'tasks.md'), 'utf-8');
      expect(tasksContent).toBeDefined();
      expect(tasksContent.length).toBeGreaterThan(0);
    });

    it('should handle PRD with multiple features', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/many-features');
      await fs.ensureDir(projectDir);

      const features = `# Many Features Project

## Requirements

### Must-Have Features

${Array.from(
        { length: 5 },
        (_, i) => `#### ${i + 1}. Feature ${i + 1}

**Behavior:**
- Create feature ${i + 1} component`
      ).join('\n\n')}`;

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), features);

      const taskManager = new TaskManager();
      await taskManager.generateTasksFromPrd(projectDir);

      const tasksContent = await fs.readFile(path.join(projectDir, 'tasks.md'), 'utf-8');
      // Should generate tasks
      expect(tasksContent).toContain('# Implementation Tasks');
      expect(tasksContent.length).toBeGreaterThan(100);
    });
  });

  describe('Null and Undefined Edge Cases', () => {
    it('should handle empty PRD file gracefully', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/empty-prd');
      await fs.ensureDir(projectDir);
      await fs.writeFile(path.join(projectDir, 'full-prd.md'), '');

      const taskManager = new TaskManager();
      await taskManager.generateTasksFromPrd(projectDir);

      const tasksContent = await fs.readFile(path.join(projectDir, 'tasks.md'), 'utf-8');
      expect(tasksContent).toBeDefined();
    });

    it('should handle PRD with only whitespace', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/whitespace-prd');
      await fs.ensureDir(projectDir);
      await fs.writeFile(path.join(projectDir, 'full-prd.md'), '   \n\n\t\n   ');

      const taskManager = new TaskManager();
      await taskManager.generateTasksFromPrd(projectDir);

      const tasksContent = await fs.readFile(path.join(projectDir, 'tasks.md'), 'utf-8');
      expect(tasksContent).toBeDefined();
    });

    it('should handle PRD with no features', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/no-features');
      await fs.ensureDir(projectDir);

      const prdContent = `# Project Overview

This is just an overview with no features defined.

## Background
Some background information.`;

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), prdContent);

      const taskManager = new TaskManager();
      await taskManager.generateTasksFromPrd(projectDir);

      const tasksContent = await fs.readFile(path.join(projectDir, 'tasks.md'), 'utf-8');
      expect(tasksContent).toBeDefined();
    });

    it('should handle empty prompt improvement', async () => {
      const optimizer = new PromptOptimizer();
      const result = optimizer.improve('', 'fast');

      expect(result).toBeDefined();
      expect(result.improved).toBeDefined();
    });

    it('should handle whitespace-only prompt', async () => {
      const optimizer = new PromptOptimizer();
      const result = optimizer.improve('   \n\n\t   ', 'fast');

      expect(result).toBeDefined();
      expect(result.improved).toBeDefined();
    });

    it('should handle single-character prompt', async () => {
      const optimizer = new PromptOptimizer();
      const result = optimizer.improve('a', 'fast');

      expect(result).toBeDefined();
      expect(result.improved).toBeDefined();
    });
  });

  describe('PRD Generator Edge Cases', () => {
    it('should handle answers with only required fields', async () => {
      const prdGenerator = new PrdGenerator();
      const answers = {
        q1: 'Build a simple app',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'minimal-answers',
      });

      expect(await fs.pathExists(path.join(projectDir, 'full-prd.md'))).toBe(true);
      expect(await fs.pathExists(path.join(projectDir, 'quick-prd.md'))).toBe(true);
    });

    it('should handle answers with all fields populated', async () => {
      const prdGenerator = new PrdGenerator();
      const answers = {
        q1: 'Build a comprehensive app',
        q2: 'Feature A, Feature B, Feature C',
        q3: 'React, Node.js, PostgreSQL, Redis',
        q4: 'Integration A, Integration B',
        q5: 'Must be GDPR compliant and support 10k concurrent users',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'full-answers',
      });

      const prdContent = await fs.readFile(path.join(projectDir, 'full-prd.md'), 'utf-8');
      expect(prdContent).toContain('comprehensive app');
      expect(prdContent).toContain('Feature A');
    });

    it('should handle very long answer values', async () => {
      const prdGenerator = new PrdGenerator();
      const longAnswer = 'Very detailed requirement. '.repeat(500); // ~15k chars

      const answers = {
        q1: longAnswer,
        q2: 'Feature 1, Feature 2',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'long-answers',
      });

      const prdContent = await fs.readFile(path.join(projectDir, 'full-prd.md'), 'utf-8');
      expect(prdContent.length).toBeGreaterThan(10000);
    });

    it('should handle special characters in answers', async () => {
      const prdGenerator = new PrdGenerator();
      const answers = {
        q1: 'Build app with <tags> & "quotes" and \'apostrophes\'',
        q2: 'Feature with $pecial ch@rs!',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'special-chars',
      });

      const prdContent = await fs.readFile(path.join(projectDir, 'full-prd.md'), 'utf-8');
      expect(prdContent).toBeDefined();
    });

    it('should handle unicode and emoji in answers', async () => {
      const prdGenerator = new PrdGenerator();
      const answers = {
        q1: 'Build app for ä¸­æ–‡ç”¨æˆ· and Ñ€ÑƒÑÑÐºÐ¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ð¸',
        q2: 'Feature with emoji support ðŸš€âœ¨',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'unicode-test',
      });

      const prdContent = await fs.readFile(path.join(projectDir, 'full-prd.md'), 'utf-8');
      expect(prdContent).toContain('ä¸­æ–‡');
      expect(prdContent).toContain('ðŸš€');
    });

    it('should handle newlines in answers', async () => {
      const prdGenerator = new PrdGenerator();
      const answers = {
        q1: 'Build app with\nmulti-line\ndescription',
        q2: 'Feature 1\nFeature 2',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'multiline-answers',
      });

      const prdContent = await fs.readFile(path.join(projectDir, 'full-prd.md'), 'utf-8');
      expect(prdContent).toBeDefined();
    });
  });

  describe('Prompt Optimizer Edge Cases', () => {
    it('should handle prompts with code blocks', async () => {
      const optimizer = new PromptOptimizer();
      const prompt = `Improve this code:
\`\`\`javascript
function test() {
  return true;
}
\`\`\``;

      const result = optimizer.improve(prompt, 'fast');
      expect(result.improved).toBeDefined();
    });

    it('should handle prompts with markdown formatting', async () => {
      const optimizer = new PromptOptimizer();
      const prompt = `# Title

## Subtitle

- Bullet 1
- Bullet 2

**Bold** and *italic* text`;

      const result = optimizer.improve(prompt, 'fast');
      expect(result.improved).toBeDefined();
    });

    it('should handle prompts with special characters', async () => {
      const optimizer = new PromptOptimizer();
      const prompt = 'Test with $pecial ch@rs & symbols: <>, {}, [], (), !, ?, %, #';

      const result = optimizer.improve(prompt, 'fast');
      expect(result.improved).toBeDefined();
    });

    it('should handle prompts with URLs', async () => {
      const optimizer = new PromptOptimizer();
      const prompt = 'Create an API that calls https://api.example.com/v1/users';

      const result = optimizer.improve(prompt, 'fast');
      expect(result.improved).toBeDefined();
    });

    it('should handle prompts with email addresses', async () => {
      const optimizer = new PromptOptimizer();
      const prompt = 'Send notifications to user@example.com and admin@test.org';

      const result = optimizer.improve(prompt, 'fast');
      expect(result.improved).toBeDefined();
    });
  });

  describe('Task Status Edge Cases', () => {
    it('should handle tasks file with mixed checkbox formats', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/mixed-checkboxes');
      await fs.ensureDir(projectDir);

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), '# Test');

      const tasksContent = `# Tasks

## Phase 1
- [ ] Unchecked with spaces
- [] Unchecked without spaces
- [x] Checked lowercase
- [X] Checked uppercase
-[ ] No space after dash
-[x] No space, checked`;

      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, tasksContent);

      const taskManager = new TaskManager();
      const phases = await taskManager.readTasksFile(tasksPath);
      const status = taskManager.getTaskStats(phases);

      expect(status.total).toBeGreaterThan(0);
    });

    it('should handle tasks with nested lists', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/nested-tasks');
      await fs.ensureDir(projectDir);

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), '# Test');

      const tasksContent = `# Tasks

## Phase 1
- [ ] Main task 1
- [ ] Main task 2
- [ ] Main task 3`;

      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, tasksContent);

      const taskManager = new TaskManager();
      const phases = await taskManager.readTasksFile(tasksPath);
      const status = taskManager.getTaskStats(phases);

      // Should count all tasks
      expect(status.total).toBe(3);
      expect(status.completed).toBe(0);
    });

    it('should handle tasks with no checkboxes', async () => {
      const projectDir = path.join(testDir, '.clavix/outputs/no-checkboxes');
      await fs.ensureDir(projectDir);

      await fs.writeFile(path.join(projectDir, 'full-prd.md'), '# Test');

      const tasksContent = `# Tasks

## Phase 1
- Task without checkbox
- Another task
* Different bullet style`;

      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, tasksContent);

      const taskManager = new TaskManager();
      const phases = await taskManager.readTasksFile(tasksPath);
      const status = taskManager.getTaskStats(phases);

      expect(status.total).toBe(0);
      expect(status.completed).toBe(0);
    });
  });
});
