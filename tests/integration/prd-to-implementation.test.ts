/**
 * Integration test for full PRD-to-implementation workflow
 * Tests the complete lifecycle: PRD generation → task planning → implementation tracking → archive
 */

import * as path from 'path';
import * as fs from 'fs-extra';
import { PrdGenerator } from '../../src/core/prd-generator';
import { TaskManager } from '../../src/core/task-manager';
import { ArchiveManager } from '../../src/core/archive-manager';

describe('PRD-to-Implementation Workflow Integration', () => {
  const testDir = path.join(__dirname, '../tmp/prd-implementation-test');
  let prdGenerator: PrdGenerator;
  let taskManager: TaskManager;
  let archiveManager: ArchiveManager;

  beforeEach(async () => {
    await fs.ensureDir(testDir);
    process.chdir(testDir);

    prdGenerator = new PrdGenerator();
    taskManager = new TaskManager();
    archiveManager = new ArchiveManager();
  });

  afterEach(async () => {
    process.chdir(path.join(__dirname, '../..'));
    await fs.remove(testDir);
  });

  describe('Complete Workflow', () => {
    it('should complete full PRD → Tasks → Implementation → Archive cycle', async () => {
      // Step 1: Generate PRD
      const answers = {
        q1: 'Build an e-commerce platform for small businesses',
        q2: 'Product catalog, Shopping cart, Payment processing',
        q3: 'React, Node.js, PostgreSQL',
        q4: 'Email marketing, CRM integration',
        q5: 'Must be PCI-DSS compliant and mobile-friendly',
      };

      const projectDir = await prdGenerator.generate(answers, {
        outputDir: '.clavix/outputs',
        projectName: 'e-commerce-platform',
      });

      expect(await fs.pathExists(projectDir)).toBe(true);
      expect(await fs.pathExists(path.join(projectDir, 'full-prd.md'))).toBe(true);
      expect(await fs.pathExists(path.join(projectDir, 'quick-prd.md'))).toBe(true);

      // Step 2: Manually create tasks file (since task generation depends on template content)
      const tasksContent = `# Implementation Tasks
**Project**: E-commerce Platform
**Generated**: ${new Date().toLocaleString()}
---

## Phase 1: Setup
- [ ] Initialize project structure
- [ ] Set up database

## Phase 2: Core Features
- [ ] Implement product catalog
- [ ] Implement shopping cart
- [ ] Integrate payment processing

---
*Generated by Clavix /clavix:plan*`;

      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, tasksContent);

      // Step 3: Check initial task status
      const projects = await archiveManager.listPrdProjects();
      expect(projects).toHaveLength(1);
      const project = projects[0];
      expect(project.taskStatus.total).toBe(5);
      expect(project.taskStatus.completed).toBe(0);
      expect(project.taskStatus.allCompleted).toBe(false);

      // Step 4: Simulate partial implementation (mark some tasks complete)
      let updatedTasks = tasksContent.replace(/- \[ \]/, '- [x]'); // Mark first task
      updatedTasks = updatedTasks.replace(/- \[ \]/, '- [x]'); // Mark second task
      await fs.writeFile(tasksPath, updatedTasks);

      // Verify partial completion
      const updatedProjects = await archiveManager.listPrdProjects();
      expect(updatedProjects[0].taskStatus.completed).toBe(2);

      // Step 5: Complete all tasks
      const allCompleted = tasksContent.replace(/- \[ \]/g, '- [x]');
      await fs.writeFile(tasksPath, allCompleted);

      // Verify all completed
      const completedProjects = await archiveManager.listPrdProjects();
      expect(completedProjects[0].taskStatus.allCompleted).toBe(true);
      expect(completedProjects[0].taskStatus.percentage).toBe(100);

      // Step 6: Archive the completed project
      const archiveResult = await archiveManager.archiveProject(project.name);
      expect(archiveResult.success).toBe(true);

      // Verify archived
      const archived = await archiveManager.listArchivedProjects();
      expect(archived).toHaveLength(1);
      expect(archived[0].name).toBe(project.name);

      // Verify PRD and tasks preserved in archive
      const archivedPrdPath = path.join('.clavix/outputs/archive', project.name, 'full-prd.md');
      const archivedTasksPath = path.join('.clavix/outputs/archive', project.name, 'tasks.md');
      expect(await fs.pathExists(archivedPrdPath)).toBe(true);
      expect(await fs.pathExists(archivedTasksPath)).toBe(true);
    });
  });

  describe('PRD Generation', () => {
    it('should generate PRD with project metadata', async () => {
      const answers = {
        q1: 'Build a test project for demonstration',
        q2: 'Feature A, Feature B',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'test-project',
      });
      const prdContent = await fs.readFile(path.join(projectDir, 'full-prd.md'), 'utf-8');

      expect(prdContent).toBeDefined();
      expect(prdContent.length).toBeGreaterThan(0);
    });

    it('should generate quick PRD for AI consumption', async () => {
      const answers = {
        q1: 'Quick test project for AI consumption',
        q2: 'Feature A, Feature B',
      };

      const projectDir = await prdGenerator.generate(answers, {
        projectName: 'quick-test',
      });
      const quickPrdContent = await fs.readFile(
        path.join(projectDir, 'quick-prd.md'),
        'utf-8'
      );

      const fullPrdContent = await fs.readFile(
        path.join(projectDir, 'full-prd.md'),
        'utf-8'
      );

      expect(quickPrdContent.length).toBeGreaterThan(0);
      expect(quickPrdContent.length).toBeLessThan(fullPrdContent.length);
    });

    it('should sanitize project names for file system', async () => {
      const projectDir = await prdGenerator.generate(
        { q1: 'Test project' },
        { projectName: 'Project with / invalid \\ characters: *' }
      );

      expect(await fs.pathExists(projectDir)).toBe(true);

      // Extract just the directory name
      const dirName = path.basename(projectDir);
      expect(dirName).not.toContain('/');
      expect(dirName).not.toContain('\\');
      expect(dirName).not.toContain(':');
      expect(dirName).not.toContain('*');
    });

    it('should create separate directories for different projects', async () => {
      await prdGenerator.generate(
        { q1: 'Project A description' },
        { projectName: 'project-a' }
      );
      await prdGenerator.generate(
        { q1: 'Project B description' },
        { projectName: 'project-b' }
      );

      const projects = await archiveManager.listPrdProjects();
      expect(projects).toHaveLength(2);
      expect(projects.map((p) => p.name)).toContain('project-a');
      expect(projects.map((p) => p.name)).toContain('project-b');
    });
  });

  describe('Task Generation', () => {
    it('should create tasks file when manually written', async () => {
      const projectDir = await prdGenerator.generate(
        { q1: 'Task test project' },
        { projectName: 'task-test' }
      );

      // Manually create tasks (simulating what /clavix:plan would do)
      const tasksContent = `# Implementation Tasks

## Phase 1: Setup
- [ ] Initialize project
- [ ] Set up dependencies

## Phase 2: Features
- [ ] Feature 1
- [ ] Feature 2`;

      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, tasksContent);

      // Verify file exists
      expect(await fs.pathExists(tasksPath)).toBe(true);

      // Verify archive manager can read it
      const projects = await archiveManager.listPrdProjects();
      expect(projects[0].taskStatus.total).toBe(4);
      expect(projects[0].taskStatus.completed).toBe(0);
    });

    it('should detect PRD file with different naming conventions', async () => {
      const projectDir = await prdGenerator.generate(
        { q1: 'Naming test' },
        { projectName: 'naming-test' }
      );

      // The current implementation creates full-prd.md
      expect(await fs.pathExists(path.join(projectDir, 'full-prd.md'))).toBe(true);

      // TaskManager.findPrdFile should find it
      // We'll verify by trying to list it
      const projects = await archiveManager.listPrdProjects();
      expect(projects).toHaveLength(1);
    });
  });

  describe('Task Status Tracking', () => {
    it('should track task completion accurately', async () => {
      const projectDir = await prdGenerator.generate({
        projectName: 'Tracking Test',
        description: 'Test task tracking',
      });

      await taskManager.generateTasksFromPrd(projectDir);

      // Manually create tasks with known counts
      const tasksContent = `# Implementation Tasks

## Phase 1: Setup
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

## Phase 2: Development
- [ ] Task 4
- [ ] Task 5`;

      await fs.writeFile(path.join(projectDir, 'tasks.md'), tasksContent);

      const projects = await archiveManager.listPrdProjects();
      const project = projects[0];

      expect(project.taskStatus.total).toBe(5);
      expect(project.taskStatus.completed).toBe(0);
      expect(project.taskStatus.remaining).toBe(5);
      expect(project.taskStatus.percentage).toBe(0);
    });

    it('should calculate correct completion percentage', async () => {
      const projectDir = await prdGenerator.generate({
        projectName: 'Percentage Test',
        description: 'Test percentage calculation',
      });

      const tasksContent = `# Tasks

## Phase 1
- [x] Task 1
- [x] Task 2
- [ ] Task 3
- [ ] Task 4`;

      await fs.writeFile(path.join(projectDir, 'tasks.md'), tasksContent);

      const projects = await archiveManager.listPrdProjects();
      expect(projects[0].taskStatus.percentage).toBe(50);
    });

    it('should identify projects ready for archive', async () => {
      // Create incomplete project
      const incomplete = await prdGenerator.generate({
        projectName: 'Incomplete',
        description: 'Incomplete project',
      });
      await fs.writeFile(
        path.join(incomplete, 'tasks.md'),
        '# Tasks\n\n## Phase 1\n- [ ] Task 1'
      );

      // Create complete project
      const complete = await prdGenerator.generate({
        projectName: 'Complete',
        description: 'Complete project',
      });
      await fs.writeFile(
        path.join(complete, 'tasks.md'),
        '# Tasks\n\n## Phase 1\n- [x] Task 1'
      );

      const archivable = await archiveManager.getArchivablePrds();
      expect(archivable).toHaveLength(1);
      expect(archivable[0].name).toBe('complete');
    });
  });

  describe('Cross-Component State Management', () => {
    it('should maintain consistency across multiple operations', async () => {
      // Generate PRD
      const projectDir = await prdGenerator.generate(
        { q1: 'Consistency test project' },
        { projectName: 'consistency-test' }
      );

      // Manually create tasks
      const tasksContent = `# Implementation Tasks

## Phase 1
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3
- [ ] Task 4`;

      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, tasksContent);

      // Verify initial state
      let projects = await archiveManager.listPrdProjects();
      expect(projects[0].taskStatus.total).toBe(4);
      expect(projects[0].taskStatus.completed).toBe(0);

      // Complete half the tasks
      let updatedTasks = tasksContent
        .replace('- [ ] Task 1', '- [x] Task 1')
        .replace('- [ ] Task 2', '- [x] Task 2');
      await fs.writeFile(tasksPath, updatedTasks);

      // Verify mid-state
      projects = await archiveManager.listPrdProjects();
      expect(projects[0].taskStatus.completed).toBe(2);
      expect(projects[0].taskStatus.remaining).toBe(2);

      // Complete all tasks
      updatedTasks = updatedTasks.replace(/- \[ \]/g, '- [x]');
      await fs.writeFile(tasksPath, updatedTasks);

      // Verify final state
      projects = await archiveManager.listPrdProjects();
      expect(projects[0].taskStatus.allCompleted).toBe(true);
      expect(projects[0].taskStatus.completed).toBe(4);
    });

    it('should handle regeneration of tasks', async () => {
      const projectDir = await prdGenerator.generate(
        { q1: 'Regeneration test' },
        { projectName: 'regeneration-test' }
      );

      // Create tasks first time
      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, '# Tasks\n\n## Phase 1\n- [ ] Task 1');

      expect(await fs.pathExists(tasksPath)).toBe(true);

      // Overwrite tasks (simulating regeneration)
      await fs.writeFile(tasksPath, '# Tasks\n\n## Phase 1\n- [ ] New Task 1');

      const content = await fs.readFile(tasksPath, 'utf-8');
      expect(content).toContain('New Task 1');
    });

    it('should support resume from partial completion', async () => {
      const projectDir = await prdGenerator.generate(
        { q1: 'Resume test' },
        { projectName: 'resume-test' }
      );

      // Create tasks with some completed
      const tasksContent = `# Tasks

## Setup
- [x] Completed task
- [ ] Incomplete task 1

## Development
- [ ] Incomplete task 2`;

      const tasksPath = path.join(projectDir, 'tasks.md');
      await fs.writeFile(tasksPath, tasksContent);

      // Get incomplete tasks
      const incomplete = await archiveManager.getIncompleteTasks(projectDir);

      expect(incomplete.length).toBe(2);
      expect(incomplete).toContain('[Setup] Incomplete task 1');
      expect(incomplete).toContain('[Development] Incomplete task 2');
    });
  });

  describe('Error Handling', () => {
    it('should handle missing PRD gracefully', async () => {
      await expect(
        taskManager.generateTasksFromPrd('.clavix/outputs/nonexistent')
      ).rejects.toThrow();
    });

    it('should handle corrupted tasks file', async () => {
      const projectDir = await prdGenerator.generate({
        projectName: 'Corrupted Test',
        description: 'Testing error handling',
      });

      // Write invalid tasks file
      await fs.writeFile(path.join(projectDir, 'tasks.md'), 'Invalid content');

      const projects = await archiveManager.listPrdProjects();
      expect(projects[0].taskStatus.total).toBe(0);
      expect(projects[0].taskStatus.hasTasksFile).toBe(true);
    });

    it('should prevent archive of incomplete projects by default', async () => {
      const projectDir = await prdGenerator.generate({
        projectName: 'Incomplete Archive Test',
        description: 'Testing archive prevention',
      });

      await fs.writeFile(
        path.join(projectDir, 'tasks.md'),
        '# Tasks\n\n## Phase 1\n- [ ] Incomplete task'
      );

      const projects = await archiveManager.listPrdProjects();
      const result = await archiveManager.archiveProject(projects[0].name);

      expect(result.success).toBe(false);
      expect(result.message).toContain('incomplete');
    });
  });
});
