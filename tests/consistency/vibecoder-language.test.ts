/**
 * Vibecoder Language Consistency Tests
 *
 * These tests ensure all canonical templates use vibecoder-friendly language
 * and avoid technical jargon that non-technical users wouldn't understand.
 *
 * CI Failure: If any banned phrase is detected, tests FAIL.
 */

import { describe, it, expect, beforeAll } from '@jest/globals';
import * as fs from 'fs';
import * as path from 'path';
import glob from 'glob';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.join(__dirname, '../..');

// Phrases that should NOT appear in user-facing documentation
// Note: These are allowed in agent-facing sections (error handling, troubleshooting, examples)
const BANNED_TECHNICAL_PHRASES = [
  // Quality dimension jargon (should use plain English)
  'quality score of',
  'score: \\d+%',
  'dimension score',
  'weighted average',
  'quality metrics',

  // Technical terms without explanation (in user-facing sections)
  'atomic operation',
  'state validation',
  'checkpoint assertion',
  'mode boundary',
  'lifecycle management',

  // Overly formal language
  'You must execute',
  'User is required to',
  'Operation aborted',
  'Process terminated',
];

// Pattern names that should only appear in agent-facing sections
// These are tested separately with section-aware logic
const PATTERN_NAMES = [
  'ConcisenessFilter',
  'ObjectiveClarifier',
  'TechnicalContextEnricher',
  'AlternativePhrasingGenerator',
  'EdgeCaseIdentifier',
  'ValidationChecklistCreator',
  'AssumptionExplicitizer',
  'ScopeDefiner',
  'PRDStructureEnforcer',
  'ErrorToleranceEnhancer',
  'PrerequisiteIdentifier',
];

// Sections where technical language is acceptable (agent-facing)
const AGENT_FACING_SECTION_MARKERS = [
  // Agent transparency sections
  'Agent Transparency',
  'Internal Reference',
  'For Internal Use',
  'Common Patterns (Internal',
  'CLI Reference',
  'Commands I Execute',
  'Commands I Run',
  // Error and troubleshooting sections
  'Error Handling',
  'Troubleshooting',
  'Agent recovery',
  'When Things Go Wrong',
  // Pattern documentation (internal)
  'What the Pattern Does',
  'generated by',
  'Pattern:',
  // Example output sections
  'Example Output',
  'What You See',
  'Sample Analysis',
  'Deep Analysis Output',
  'Patterns Applied',
  'Applied patterns',
  'What I Generate',
  // v4.11 output format sections
  'Output Format',
  'Depth Output Format',
  'Standard Depth Output',
  'Comprehensive Depth Output',
  'Depth Selection',
  'Smart Depth Selection',
];

// Phrases that SHOULD appear (positive validation)
const REQUIRED_FRIENDLY_PHRASES = [
  // Agent-first language
  'I will',
  "I'll",
  'Let me',
  'I handle',
  'I run',

  // Friendly explanations
  'What this does',
  'How it works',
  'When things go wrong',

  // User-friendly status
  'Done!',
  'Ready',
  "Let's",
];

// Files to test for user-facing language (canonical templates only)
// Component files are agent-facing and excluded from banned phrase checks
const FILES_TO_TEST = ['src/templates/slash-commands/_canonical/**/*.md'];

// Component files that are specifically for agent consumption (more lenient)
const AGENT_FACING_COMPONENT_FILES = [
  'src/templates/slash-commands/_components/agent-protocols/**/*.md',
  'src/templates/slash-commands/_components/troubleshooting/**/*.md',
  'src/templates/slash-commands/_components/sections/improvement-explanations.md',
];

describe('Vibecoder Language Consistency', () => {
  let templateFiles: string[] = [];
  let fileContents: Map<string, string> = new Map();

  beforeAll(() => {
    for (const pattern of FILES_TO_TEST) {
      const matches = glob.sync(pattern, { cwd: projectRoot });
      templateFiles.push(...matches);
    }

    // Read all file contents
    for (const file of templateFiles) {
      const fullPath = path.join(projectRoot, file);
      if (fs.existsSync(fullPath)) {
        fileContents.set(file, fs.readFileSync(fullPath, 'utf-8'));
      }
    }
  });

  // Helper function to check if a line is in an agent-facing section
  function isInAgentFacingSection(lines: string[], lineIndex: number): boolean {
    // Look backwards to find section headers
    for (let i = lineIndex; i >= 0; i--) {
      const line = lines[i];

      // Check for agent-facing section markers
      if (AGENT_FACING_SECTION_MARKERS.some((marker) => line.includes(marker))) {
        return true;
      }

      // If we hit a major section header (##) that's not agent-facing, we're in user-facing section
      if (
        line.startsWith('## ') &&
        !AGENT_FACING_SECTION_MARKERS.some((marker) => line.includes(marker))
      ) {
        return false;
      }
    }
    return false;
  }

  describe('Banned Technical Phrases', () => {
    it('should find template files to test', () => {
      expect(templateFiles.length).toBeGreaterThan(0);
    });

    for (const phrase of BANNED_TECHNICAL_PHRASES) {
      it(`should NOT contain banned phrase: "${phrase}"`, () => {
        const regex = new RegExp(phrase, 'gi');
        const violations: string[] = [];

        for (const [file, content] of fileContents) {
          if (!regex.test(content)) continue;

          const lines = content.split('\n');
          for (let i = 0; i < lines.length; i++) {
            if (regex.test(lines[i])) {
              // Skip if in agent-facing section
              if (!isInAgentFacingSection(lines, i)) {
                violations.push(`${file}:${i + 1}: ${lines[i].trim()}`);
              }
            }
          }
        }

        if (violations.length > 0) {
          console.error(`\nViolations for "${phrase}":\n${violations.join('\n')}`);
        }

        expect(violations).toHaveLength(0);
      });
    }
  });

  describe('Pattern Names in User-Facing Sections', () => {
    for (const pattern of PATTERN_NAMES) {
      it(`should NOT have pattern name "${pattern}" in user-facing sections`, () => {
        const regex = new RegExp(pattern, 'gi');
        const violations: string[] = [];

        for (const [file, content] of fileContents) {
          if (!regex.test(content)) continue;

          const lines = content.split('\n');
          for (let i = 0; i < lines.length; i++) {
            if (regex.test(lines[i])) {
              // Skip if in agent-facing section
              if (!isInAgentFacingSection(lines, i)) {
                violations.push(`${file}:${i + 1}: ${lines[i].trim()}`);
              }
            }
          }
        }

        if (violations.length > 0) {
          console.error(
            `\nPattern name "${pattern}" found in user-facing sections:\n${violations.join('\n')}`
          );
        }

        expect(violations).toHaveLength(0);
      });
    }
  });

  describe('Required Friendly Language', () => {
    it('should contain at least some friendly phrases in canonical templates', () => {
      const canonicalFiles = Array.from(fileContents.entries()).filter(([file]) =>
        file.includes('_canonical')
      );

      for (const [file, content] of canonicalFiles) {
        const hasAnyFriendlyPhrase = REQUIRED_FRIENDLY_PHRASES.some((phrase) => {
          return content.toLowerCase().includes(phrase.toLowerCase());
        });

        expect(hasAnyFriendlyPhrase).toBe(true);
      }
    });
  });

  describe('User-Directed Commands Detection', () => {
    const USER_COMMAND_PATTERNS = [
      // Commands telling user to run something (should be agent-first)
      /Run this command:/i,
      /Execute the following:/i,
      /Type this in your terminal:/i,
      /User should run:/i,
      /You need to run:/i,
    ];

    // Exceptions for legitimate user instructions
    const EXCEPTIONS = [
      'you can run', // Offering choice
      'Ready to', // Offering action
      'want me to', // Agent offering
      'if you want to', // Optional
    ];

    it('should not have user-directed CLI commands outside of reference sections', () => {
      const violations: string[] = [];

      for (const [file, content] of fileContents) {
        const lines = content.split('\n');
        let inReferenceSection = false;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Track reference sections
          if (
            line.includes('Reference') ||
            line.includes('Commands I Run') ||
            line.includes('Commands I Execute') ||
            line.includes('Internal')
          ) {
            inReferenceSection = true;
          }
          if (inReferenceSection && line.startsWith('## ')) {
            inReferenceSection = false;
          }

          // Skip reference sections
          if (inReferenceSection) continue;

          // Check for violations
          for (const pattern of USER_COMMAND_PATTERNS) {
            if (pattern.test(line)) {
              // Check exceptions
              const hasException = EXCEPTIONS.some((exc) =>
                line.toLowerCase().includes(exc.toLowerCase())
              );

              if (!hasException) {
                violations.push(`${file}:${i + 1}: ${line.trim()}`);
              }
            }
          }
        }
      }

      if (violations.length > 0) {
        console.error(`\nUser-directed command violations:\n${violations.join('\n')}`);
      }

      expect(violations).toHaveLength(0);
    });
  });
});
