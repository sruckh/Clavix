// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Optimization Output Snapshots deep mode output structure should produce consistent structure with alternatives: deep-mode-with-alternatives 1`] = `
"{
  "appliedPatterns": [
    {
      "description": "Identifies and clarifies ambiguous terms and vague references",
      "impact": "low",
      "name": "Ambiguity Detector"
    },
    {
      "description": "Adds explicit output format specifications for agent clarity",
      "impact": "medium",
      "name": "Output Format Enforcer"
    },
    {
      "description": "Adds measurable success criteria for task completion validation",
      "impact": "medium",
      "name": "Success Criteria Enforcer"
    },
    {
      "description": "Ensures all necessary requirements are present",
      "impact": "medium",
      "name": "Completeness Validator"
    },
    {
      "description": "Make implicit assumptions explicit to prevent misunderstandings",
      "impact": "high",
      "name": "Assumption Explicitizer"
    },
    {
      "description": "Add precise context when missing",
      "impact": "high",
      "name": "Context Precision Booster"
    },
    {
      "description": "Identifies and documents prerequisites and dependencies for task execution",
      "impact": "medium",
      "name": "Prerequisite Identifier"
    },
    {
      "description": "Adds missing technical context (language, framework, versions)",
      "impact": "medium",
      "name": "Technical Context Enricher"
    },
    {
      "description": "Add explicit scope boundaries to prevent scope creep",
      "impact": "medium",
      "name": "Scope Definer"
    },
    {
      "description": "Break complex prompts into clear sequential steps",
      "impact": "high",
      "name": "Step-by-Step Decomposer"
    },
    {
      "description": "Adds domain-specific best practices and context",
      "impact": "medium",
      "name": "Domain Context Enricher"
    },
    {
      "description": "Removes unnecessary pleasantries, fluff words, and redundancy",
      "impact": "low",
      "name": "Conciseness Filter"
    },
    {
      "description": "Converts vague goals into specific, actionable tasks",
      "impact": "low",
      "name": "Actionability Enhancer"
    },
    {
      "description": "Identify potential edge cases and failure modes by domain",
      "impact": "high",
      "name": "Edge Case Identifier"
    },
    {
      "description": "Generate alternative prompt structures for different approaches",
      "impact": "medium",
      "name": "Alternative Phrasing Generator"
    },
    {
      "description": "Create implementation validation checklist for verification",
      "impact": "high",
      "name": "Validation Checklist Creator"
    }
  ],
  "enhanced": "Add dark mode to my app ## Clarifications Needed [CLARIFY: /"app/" - specify: web app, mobile app, desktop app?] ## Expected Output Format Specify the desired output format: - TypeScript/JavaScript function with type annotations - React component with props interface - Module with exports - Class with methods - API endpoint implementation **Note**: Explicit output format helps ensure consistent, usable results. ## Success Criteria This task is complete when: - [ ] Code compiles/transpiles without errors - [ ] All tests pass (if tests are written) - [ ] Follows project coding standards - [ ] No TypeScript/linting errors - [ ] Functionality matches requirements - [ ] Edge cases are handled **Tip**: Check off criteria as you complete them to track progress. --- **Completeness Check**: 60% (3/5 elements present) **Missing Information** (please specify): - **Objective**: What is the primary goal? What problem are you solving? - **Constraints**: Any limitations? (time, budget, performance, compatibility) ### Implicit Assumptions The following assumptions are being made. Please clarify if any are incorrect: **1. Using async/await pattern** → Clarify: Should this be synchronous or asynchronous? **2. Building REST API** → Clarify: Which API style? (REST, GraphQL, gRPC, etc.) ### Context Needed Please provide additional context for better (e.g., faster) results: **1. Which file(s) should this be implemented in?** _Suggestion: Specify the file path (e.g., src/utils/helpers.ts)_ ## Prerequisites Before starting this task, ensure: - [ ] Development environment set up - [ ] Required dependencies installed - [ ] Coding standards/style guide available - [ ] Node.js >= 16.x installed - [ ] npm or yarn package manager - [ ] TypeScript installed - [ ] tsconfig.json configured - [ ] API endpoint accessible **Note**: Check prerequisites to avoid blockers during implementation. # Technical Constraints - Language: JavaScript (please specify version if critical) - Framework: React ### Scope Definition **In Scope:** ✓ Component implementation with specified functionality ✓ API endpoint implementation **Out of Scope:** ✗ Deployment and CI/CD configuration ✗ Production infrastructure setup ✗ Extensive documentation **Boundaries & Assumptions:** • Limited to specified component/module boundaries • Following existing project conventions and patterns ### Implementation Steps 1. Define component interface and props 2. Implement core component logic 3. Add styling and responsive design 4. Add error handling and edge cases 5. Write unit tests ## Domain Best Practices (api, frontend) Consider these best practices: - Use consistent response formats (JSON:API, HAL, etc.) - Implement proper HTTP status codes - Version your API (URL path or header) - Follow WCAG accessibility guidelines - Implement responsive design - Use semantic HTML elements **Note**: These are general best practices - adapt to your specific context./n/n### Edge Cases to Consider/n/n• **Empty or null inputs**: How should the system handle missing or undefined values?/n• **Invalid input types**: What happens if input is wrong type (string vs number)?/n• **Network failures**: How to handle timeouts, connection errors, and retries?/n• **Boundary conditions**: What happens at min/max values, empty collections, or single items?/n• **Race conditions**: What if multiple operations access shared state simultaneously?/n• **Large files**: What are size limits? How to handle files that exceed limits?/n• **Malicious files**: How to validate file types and scan for malware?/n• **Timezone handling**: How to handle users in different timezones?/n/n### Alternative Approaches/n/n**1. Functional Decomposition**/n   Break down into discrete functions with clear interfaces/n   → Best for: Step-by-step implementation, clarity on sequence/n/n**2. Test-Driven Approach**/n   Define expected behavior through tests first/n   → Best for: When requirements are clear and testable/n/n**3. Example-Driven**/n   Provide concrete input/output examples/n   → Best for: When you have reference implementations/n/n/n### Validation Checklist/n/nBefore considering this task complete, verify:/n/n**Functionality:**/n☐ Code compiles/runs without errors/n☐ All requirements from prompt are implemented/n☐ API returns correct status codes/n☐ File uploads work for valid files/n/n**Robustness:**/n☐ Edge cases are handled gracefully/n☐ API handles invalid requests gracefully/n/n**Ux:**/n☐ UI renders correctly on different screen sizes/n/n**Accessibility:**/n☐ Keyboard navigation works correctly/n/n**Testing:**/n☐ Unit tests pass/n☐ Test coverage meets requirements/n/n**Validation:**/n☐ Invalid/large files are rejected gracefully/n/n**Quality:**/n☐ Code follows project conventions/style guide",
  "improvements": [
    {
      "description": "Identified 1 ambiguous terms/phrases requiring clarification",
      "dimension": "clarity",
      "impact": "low"
    },
    {
      "description": "Added output format guidance for code-generation intent",
      "dimension": "actionability",
      "impact": "medium"
    },
    {
      "description": "Added 6 measurable success criteria for code-generation",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Added 2 missing element prompts (60% complete)",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Identified 2 implicit assumptions to clarify",
      "dimension": "clarity",
      "impact": "high"
    },
    {
      "description": "Identified 1 areas needing context clarification",
      "dimension": "completeness",
      "impact": "high"
    },
    {
      "description": "Added 8 prerequisites for react, typescript, api",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Added 2 technical context specifications",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Added explicit scope boundaries",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Decomposed into 5 sequential steps",
      "dimension": "structure",
      "impact": "high"
    },
    {
      "description": "Added 6 best practices for api, frontend",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Removed 0 unnecessary phrases for conciseness",
      "dimension": "efficiency",
      "impact": "low"
    },
    {
      "description": "Made 1 improvements to increase specificity",
      "dimension": "actionability",
      "impact": "low"
    },
    {
      "description": "Identified 8 potential edge cases",
      "dimension": "completeness",
      "impact": "high"
    },
    {
      "description": "Generated 3 alternative approaches",
      "dimension": "structure",
      "impact": "medium"
    },
    {
      "description": "Created validation checklist with 12 items",
      "dimension": "actionability",
      "impact": "high"
    }
  ],
  "intent": {
    "characteristics": {
      "hasCodeContext": false,
      "hasTechnicalTerms": false,
      "isOpenEnded": false,
      "needsStructure": true
    },
    "confidence": 50,
    "primaryIntent": "code-generation",
    "suggestedMode": "deep"
  },
  "mode": "deep",
  "original": "Add dark mode to my app",
  "processingTimeMs": "[PROCESSING_TIME]",
  "quality": {
    "actionability": 10,
    "clarity": 100,
    "completeness": 100,
    "efficiency": 80,
    "improvements": [
      "Added missing context and specifications",
      "Added technical context"
    ],
    "overall": 80,
    "specificity": 100,
    "strengths": [
      "Clear objective and goals",
      "Well-structured with logical flow",
      "Comprehensive with all necessary details",
      "Highly specific with concrete details"
    ],
    "structure": 100
  }
}"
`;

exports[`Optimization Output Snapshots fast mode output structure should produce consistent structure for complex prompts: fast-mode-complex-prompt 1`] = `
"{
  "appliedPatterns": [
    {
      "description": "Identifies and clarifies ambiguous terms and vague references",
      "impact": "high",
      "name": "Ambiguity Detector"
    },
    {
      "description": "Adds explicit output format specifications for agent clarity",
      "impact": "medium",
      "name": "Output Format Enforcer"
    },
    {
      "description": "Adds measurable success criteria for task completion validation",
      "impact": "medium",
      "name": "Success Criteria Enforcer"
    },
    {
      "description": "Ensures all necessary requirements are present",
      "impact": "low",
      "name": "Completeness Validator"
    },
    {
      "description": "Add precise context when missing",
      "impact": "high",
      "name": "Context Precision Booster"
    },
    {
      "description": "Adds missing technical context (language, framework, versions)",
      "impact": "medium",
      "name": "Technical Context Enricher"
    },
    {
      "description": "Break complex prompts into clear sequential steps",
      "impact": "high",
      "name": "Step-by-Step Decomposer"
    },
    {
      "description": "Adds domain-specific best practices and context",
      "impact": "medium",
      "name": "Domain Context Enricher"
    },
    {
      "description": "Removes unnecessary pleasantries, fluff words, and redundancy",
      "impact": "low",
      "name": "Conciseness Filter"
    },
    {
      "description": "Converts vague goals into specific, actionable tasks",
      "impact": "low",
      "name": "Actionability Enhancer"
    }
  ],
  "enhanced": "I need to build a user authentication system that supports: - Email/password login - OAuth with Google and GitHub - Two-factor authentication - Password reset flow Please include security best practices. ## Clarifications Needed [CLARIFY: /"system/" - specify: backend system, frontend system, full-stack system?] [CLARIFY: /"authentication/" - specify: OAuth, JWT, session-[ID]?] [CLARIFY: /"user/" - specify: end user, admin user, API consumer?] [CLARIFY: /"best/" - specify: optimal, industry standard, team consensus?] ## Expected Output Format Specify the desired output format: - TypeScript/JavaScript function with type annotations - React component with props interface - Module with exports - Class with methods - API endpoint implementation **Note**: Explicit output format helps ensure consistent, usable results. ## Success Criteria This task is complete when: - [ ] Code compiles/transpiles without errors - [ ] All tests pass (if tests are written) - [ ] Follows project coding standards - [ ] No TypeScript/linting errors - [ ] Functionality matches requirements - [ ] Edge cases are handled **Tip**: Check off criteria as you complete them to track progress. --- **Completeness Check**: 80% (4/5 elements present) **Missing Information** (please specify): - **Constraints**: Any limitations? (time, budget, performance, compatibility) ### Context Needed Please provide additional context for better (e.g., faster) results: **1. Which file(s) should this be implemented in?** _Suggestion: Specify the file path (e.g., src/utils/helpers.ts)_ # Technical Constraints - Language: JavaScript (please specify version if critical) - Framework: React ### Implementation Steps 1. Define component interface and props 2. Implement core component logic 3. Add styling and responsive design 4. Add error handling and edge cases 5. Write unit tests ## Domain Best Practices (authentication, api) Consider these best practices: - Never store plain-text passwords - use bcrypt/argon2 - Implement rate limiting on auth endpoints - Use secure, httpOnly cookies for session tokens - Use consistent response formats (JSON:API, HAL, etc.) - Implement proper HTTP status codes - Version your API (URL path or header) **Note**: These are general best practices - adapt to your specific context.",
  "improvements": [
    {
      "description": "Identified 4 ambiguous terms/phrases requiring clarification",
      "dimension": "clarity",
      "impact": "high"
    },
    {
      "description": "Added output format guidance for code-generation intent",
      "dimension": "actionability",
      "impact": "medium"
    },
    {
      "description": "Added 6 measurable success criteria for code-generation",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Added 1 missing element prompts (80% complete)",
      "dimension": "completeness",
      "impact": "low"
    },
    {
      "description": "Identified 1 areas needing context clarification",
      "dimension": "completeness",
      "impact": "high"
    },
    {
      "description": "Added 2 technical context specifications",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Decomposed into 5 sequential steps",
      "dimension": "structure",
      "impact": "high"
    },
    {
      "description": "Added 6 best practices for authentication, api",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Removed 0 unnecessary phrases for conciseness",
      "dimension": "efficiency",
      "impact": "low"
    },
    {
      "description": "Made 1 improvements to increase specificity",
      "dimension": "actionability",
      "impact": "low"
    }
  ],
  "intent": {
    "characteristics": {
      "hasCodeContext": false,
      "hasTechnicalTerms": true,
      "isOpenEnded": true,
      "needsStructure": false
    },
    "confidence": 50,
    "primaryIntent": "code-generation",
    "suggestedMode": "deep"
  },
  "mode": "fast",
  "original": "/n        I need to build a user authentication system that supports:/n        - Email/password login/n        - OAuth with Google and GitHub/n        - Two-factor authentication/n        - Password reset flow/n        Please include security best practices./n      ",
  "processingTimeMs": "[PROCESSING_TIME]",
  "quality": {
    "actionability": 60,
    "clarity": 100,
    "completeness": 100,
    "efficiency": 80,
    "improvements": [
      "Added missing context and specifications",
      "Added technical context"
    ],
    "overall": 90,
    "specificity": 100,
    "strengths": [
      "Clear objective and goals",
      "Well-structured with logical flow",
      "Comprehensive with all necessary details",
      "Highly specific with concrete details"
    ],
    "structure": 100
  }
}"
`;

exports[`Optimization Output Snapshots fast mode output structure should produce consistent structure for simple prompts: fast-mode-simple-prompt 1`] = `
"{
  "appliedPatterns": [
    {
      "description": "Extracts or infers clear goal statement",
      "impact": "high",
      "name": "Objective Clarifier"
    },
    {
      "description": "Identifies and clarifies ambiguous terms and vague references",
      "impact": "low",
      "name": "Ambiguity Detector"
    },
    {
      "description": "Adds explicit output format specifications for agent clarity",
      "impact": "medium",
      "name": "Output Format Enforcer"
    },
    {
      "description": "Adds measurable success criteria for task completion validation",
      "impact": "medium",
      "name": "Success Criteria Enforcer"
    },
    {
      "description": "Ensures all necessary requirements are present",
      "impact": "low",
      "name": "Completeness Validator"
    },
    {
      "description": "Add precise context when missing",
      "impact": "high",
      "name": "Context Precision Booster"
    },
    {
      "description": "Adds missing technical context (language, framework, versions)",
      "impact": "medium",
      "name": "Technical Context Enricher"
    },
    {
      "description": "Break complex prompts into clear sequential steps",
      "impact": "high",
      "name": "Step-by-Step Decomposer"
    },
    {
      "description": "Adds domain-specific best practices and context",
      "impact": "medium",
      "name": "Domain Context Enricher"
    },
    {
      "description": "Removes unnecessary pleasantries, fluff words, and redundancy",
      "impact": "low",
      "name": "Conciseness Filter"
    },
    {
      "description": "Converts vague goals into specific, actionable tasks",
      "impact": "low",
      "name": "Actionability Enhancer"
    }
  ],
  "enhanced": "# Objective a login page Create a login page ## Clarifications Needed [CLARIFY: /"create/" - specify: generate, implement, design?] ## Expected Output Format Specify the desired output format: - TypeScript/JavaScript function with type annotations - React component with props interface - Module with exports - Class with methods - API endpoint implementation **Note**: Explicit output format helps ensure consistent, usable results. ## Success Criteria This task is complete when: - [ ] Code compiles/transpiles without errors - [ ] All tests pass (if tests are written) - [ ] Follows project coding standards - [ ] No TypeScript/linting errors - [ ] Functionality matches requirements - [ ] Edge cases are handled **Tip**: Check off criteria as you complete them to track progress. --- **Completeness Check**: 80% (4/5 elements present) **Missing Information** (please specify): - **Constraints**: Any limitations? (time, budget, performance, compatibility) ### Context Needed Please provide additional context for better (e.g., faster) results: **1. Which file(s) should this be implemented in?** _Suggestion: Specify the file path (e.g., src/utils/helpers.ts)_ # Technical Constraints - Language: JavaScript (please specify version if critical) - Framework: React ### Implementation Steps 1. Define component interface and props 2. Implement core component logic 3. Add styling and responsive design 4. Add error handling and edge cases 5. Write unit tests ## Domain Best Practices (authentication, api) Consider these best practices: - Never store plain-text passwords - use bcrypt/argon2 - Implement rate limiting on auth endpoints - Use secure, httpOnly cookies for session tokens - Use consistent response formats (JSON:API, HAL, etc.) - Implement proper HTTP status codes - Version your API (URL path or header) **Note**: These are general best practices - adapt to your specific context.",
  "improvements": [
    {
      "description": "Added clear objective statement",
      "dimension": "clarity",
      "impact": "high"
    },
    {
      "description": "Identified 1 ambiguous terms/phrases requiring clarification",
      "dimension": "clarity",
      "impact": "low"
    },
    {
      "description": "Added output format guidance for code-generation intent",
      "dimension": "actionability",
      "impact": "medium"
    },
    {
      "description": "Added 6 measurable success criteria for code-generation",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Added 1 missing element prompts (80% complete)",
      "dimension": "completeness",
      "impact": "low"
    },
    {
      "description": "Identified 1 areas needing context clarification",
      "dimension": "completeness",
      "impact": "high"
    },
    {
      "description": "Added 2 technical context specifications",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Decomposed into 5 sequential steps",
      "dimension": "structure",
      "impact": "high"
    },
    {
      "description": "Added 6 best practices for authentication, api",
      "dimension": "completeness",
      "impact": "medium"
    },
    {
      "description": "Removed 0 unnecessary phrases for conciseness",
      "dimension": "efficiency",
      "impact": "low"
    },
    {
      "description": "Made 1 improvements to increase specificity",
      "dimension": "actionability",
      "impact": "low"
    }
  ],
  "intent": {
    "characteristics": {
      "hasCodeContext": false,
      "hasTechnicalTerms": false,
      "isOpenEnded": false,
      "needsStructure": true
    },
    "confidence": 100,
    "primaryIntent": "code-generation",
    "suggestedMode": "deep"
  },
  "mode": "fast",
  "original": "Create a login page",
  "processingTimeMs": "[PROCESSING_TIME]",
  "quality": {
    "actionability": 90,
    "clarity": 100,
    "completeness": 100,
    "efficiency": 80,
    "improvements": [
      "Added missing context and specifications",
      "Added clear objective statement",
      "Added technical context"
    ],
    "overall": 96,
    "specificity": 100,
    "strengths": [
      "Clear objective and goals",
      "Well-structured with logical flow",
      "Comprehensive with all necessary details",
      "Immediately actionable",
      "Highly specific with concrete details"
    ],
    "structure": 100
  }
}"
`;

exports[`Optimization Output Snapshots quality assessment structure quality dimension keys should match snapshot structure: quality-dimension-keys 1`] = `
[
  "actionability",
  "clarity",
  "completeness",
  "efficiency",
  "specificity",
  "structure",
]
`;
